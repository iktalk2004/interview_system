# 程序员八股文题目训练系统 - 从零搭建指南

## 目录
1. [项目概述](#项目概述)
2. [技术栈](#技术栈)
3. [环境准备](#环境准备)
4. [后端搭建流程](#后端搭建流程)
5. [前端搭建流程](#前端搭建流程)
6. [数据库设计](#数据库设计)
7. [核心功能实现](#核心功能实现)
8. [部署指南](#部署指南)

---

## 项目概述

本项目是一个基于协同过滤算法的程序员八股文题目训练平台，提供智能题目推荐、答题练习、成绩分析等功能。

### 核心功能
- 用户管理：注册、登录、个人资料管理
- 题目管理：题目的增删改查、分类管理
- 答题练习：在线答题、自动评分、错题本
- 智能推荐：基于协同过滤的个性化题目推荐
- 数据分析：学习进度统计、成绩分析、排行榜
- 代码练习：在线代码编辑器、代码执行、AI评分

---

## 技术栈

### 后端
- **框架**: Django 5.2.8
- **API框架**: Django REST Framework 3.15.0
- **认证**: Django REST Framework SimpleJWT 5.3.0
- **数据库**: SQLite（开发）/ PostgreSQL（生产）
- **缓存**: Redis
- **任务队列**: Celery
- **AI模型**: sentence-transformers（语义相似度）
- **API文档**: drf-yasg（Swagger）

### 前端
- **框架**: Vue 3.5.26
- **构建工具**: Vite 7.3.0
- **UI组件库**: Element Plus 2.13.1
- **状态管理**: Pinia 2.3.1
- **路由**: Vue Router 4.6.4
- **HTTP客户端**: Axios 1.13.2
- **图表库**: ECharts 5.4.3
- **代码编辑器**: Monaco Editor 0.55.1

---

## 环境准备

### 系统要求
- Python 3.10+
- Node.js 20.19.0+ 或 22.12.0+
- Redis 5.0+（可选，用于缓存）
- Git

### 1. 克隆项目
```bash
git clone <repository-url>
cd 04_Interview_system
```

### 2. 创建虚拟环境（后端）
```bash
cd backend
python -m venv venv

# Windows
venv\Scripts\activate

# Linux/Mac
source venv/bin/activate
```

### 3. 安装后端依赖
```bash
pip install -r requirements.txt
```

### 4. 安装前端依赖
```bash
cd ../frontend
npm install
```

---

## 后端搭建流程

### 步骤1: 创建Django项目

```bash
cd backend
django-admin startproject core .
```

**说明**:
- `django-admin startproject` 是Django的命令行工具
- `core` 是项目名称
- `.` 表示在当前目录创建项目

### 步骤2: 创建Django应用

```bash
python manage.py startapp users
python manage.py startapp questions
python manage.py startapp practice
python manage.py startapp recommender
python manage.py startapp analytics
python manage.py startapp scoring
python manage.py startapp admin_dashboard
python manage.py startapp code_questions
python manage.py startapp audit
```

**说明**:
- 每个应用负责特定的功能模块
- `users`: 用户管理
- `questions`: 题目管理
- `practice`: 答题练习
- `recommender`: 推荐算法
- `analytics`: 数据分析
- `scoring`: 评分系统
- `admin_dashboard`: 管理后台
- `code_questions`: 代码题目
- `audit`: 审计日志

### 步骤3: 配置settings.py

```python
from pathlib import Path
import os
from dotenv import load_dotenv

BASE_DIR = Path(__file__).resolve().parent.parent
load_dotenv(os.path.join(BASE_DIR, '.env'))

SECRET_KEY = os.getenv('SECRET_KEY')
DEBUG = os.getenv('DEBUG', 'False') == 'True'
ALLOWED_HOSTS = os.getenv('ALLOWED_HOSTS', '').split(',')
```

**说明**:
- `BASE_DIR`: 项目根目录路径
- `load_dotenv()`: 加载环境变量
- `SECRET_KEY`: Django加密密钥（必须保密）
- `DEBUG`: 调试模式（生产环境设为False）
- `ALLOWED_HOSTS`: 允许访问的主机列表

### 步骤4: 注册应用

```python
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # 第三方应用
    "rest_framework",
    "corsheaders",
    "rest_framework_simplejwt",
    "rest_framework_simplejwt.token_blacklist",
    "django_filters",
    # 自定义应用
    "users",
    "questions",
    "practice",
    "recommender",
    "analytics",
    "scoring",
    "admin_dashboard",
    "code_questions",
    "audit",
]
```

**说明**:
- `INSTALLED_APPS`: Django需要知道哪些应用已安装
- 第三方应用提供额外功能（REST API、JWT认证等）
- 自定义应用是项目的核心功能模块

### 步骤5: 配置REST Framework

```python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/day',
        'user': '1000/day'
    },
}
```

**说明**:
- `DEFAULT_AUTHENTICATION_CLASSES`: 默认认证方式（JWT + Session）
- `DEFAULT_PERMISSION_CLASSES`: 默认权限（需要认证）
- `DEFAULT_THROTTLE_CLASSES`: 限流配置
- `DEFAULT_THROTTLE_RATES`: 限流速率

### 步骤6: 配置JWT

```python
from datetime import timedelta

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=15),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'AUTH_HEADER_TYPES': ('Bearer',),
}
```

**说明**:
- `ACCESS_TOKEN_LIFETIME`: 访问令牌有效期（15分钟）
- `REFRESH_TOKEN_LIFETIME`: 刷新令牌有效期（7天）
- `ROTATE_REFRESH_TOKENS`: 刷新时生成新令牌
- `BLACKLIST_AFTER_ROTATION`: 旧令牌加入黑名单

### 步骤7: 配置CORS

```python
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

CORS_ALLOW_CREDENTIALS = True
```

**说明**:
- `CORS_ALLOWED_ORIGINS`: 允许跨域访问的前端地址
- `CORS_ALLOW_CREDENTIALS`: 允许携带Cookie

### 步骤8: 配置数据库

```python
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
        "OPTIONS": {
            "timeout": 20,
            "check_same_thread": False,
        },
        "CONN_MAX_AGE": 60,
    }
}
```

**说明**:
- `ENGINE`: 数据库引擎（SQLite）
- `NAME`: 数据库文件路径
- `OPTIONS`: 数据库选项
- `CONN_MAX_AGE`: 连接池最大存活时间

### 步骤9: 配置缓存

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://localhost:6379/0',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        },
        'KEY_PREFIX': 'interview_system',
        'TIMEOUT': 300,
    }
}
```

**说明**:
- `BACKEND`: 缓存后端（Redis）
- `LOCATION`: Redis连接地址
- `KEY_PREFIX`: 缓存键前缀
- `TIMEOUT`: 默认缓存时间（秒）

### 步骤10: 配置URL路由

```python
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenRefreshView

urlpatterns = [
    path("admin/", admin.site.urls),
    path("api/v1/users/", include("users.urls")),
    path("api/v1/questions/", include("questions.urls")),
    path('api/v1/practice/', include('practice.urls')),
    path('api/v1/recommender/', include('recommender.urls')),
    path('api/v1/analytics/', include('analytics.urls')),
    path('api/v1/scoring/', include('scoring.urls')),
    path('api/v1/admin/', include('admin_dashboard.urls')),
    path('api/v1/code-questions/', include('code_questions.urls')),
    path("api/v1/token/refresh", TokenRefreshView.as_view(), name="token_refresh"),
]
```

**说明**:
- `path()`: URL路由配置
- `include()`: 包含其他应用的URL配置
- `TokenRefreshView`: JWT令牌刷新视图

### 步骤11: 创建数据库迁移

```bash
python manage.py makemigrations
python manage.py migrate
```

**说明**:
- `makemigrations`: 根据模型变更创建迁移文件
- `migrate`: 应用迁移到数据库

### 步骤12: 创建超级用户

```bash
python manage.py createsuperuser
```

**说明**:
- 创建管理员账户用于访问Django后台

### 步骤13: 运行开发服务器

```bash
python manage.py runserver
```

**说明**:
- 启动Django开发服务器
- 默认地址: http://localhost:8000

---

## 前端搭建流程

### 步骤1: 创建Vue项目

```bash
cd frontend
npm create vite@latest . -- --template vue
```

**说明**:
- `npm create vite@latest`: 使用Vite创建Vue项目
- `.`: 在当前目录创建
- `--template vue`: 使用Vue模板

### 步骤2: 安装依赖

```bash
npm install vue-router pinia axios element-plus echarts monaco-editor lodash
npm install -D @vitejs/plugin-vue vite-plugin-vue-devtools
```

**说明**:
- `vue-router`: Vue路由
- `pinia`: Vue状态管理
- `axios`: HTTP客户端
- `element-plus`: UI组件库
- `echarts`: 图表库
- `monaco-editor`: 代码编辑器
- `lodash`: 工具库

### 步骤3: 配置Vite

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true
      }
    }
  }
})
```

**说明**:
- `plugins`: Vite插件配置
- `resolve.alias`: 路径别名（@指向src目录）
- `server.proxy`: API代理配置

### 步骤4: 创建main.js

```javascript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.use(ElementPlus)
app.use(router)

app.mount('#app')
```

**说明**:
- `createApp()`: 创建Vue应用实例
- `createPinia()`: 创建Pinia状态管理
- `app.use()`: 注册插件
- `app.mount()`: 挂载应用到DOM

### 步骤5: 配置路由

```javascript
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  { path: '/', redirect: '/dashboard' },
  { path: '/dashboard', component: () => import('@/components/Dashboard.vue'), meta: { requiresAuth: true } },
  { path: '/practice', component: () => import('@/components/Practice.vue'), meta: { requiresAuth: true } },
  { path: '/recommendations', component: () => import('@/components/Recommendations.vue'), meta: { requiresAuth: true } },
  { path: '/profile', component: () => import('@/components/Profile.vue'), meta: { requiresAuth: true } },
  { path: '/login', component: () => import('@/components/Login.vue'), meta: { requiresAuth: false } },
  { path: '/register', component: () => import('@/components/Register.vue'), meta: { requiresAuth: false } },
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('token')
  if (to.meta.requiresAuth && !token) {
    next('/login')
  } else {
    next()
  }
})

export default router
```

**说明**:
- `createRouter()`: 创建路由实例
- `createWebHistory()`: 使用HTML5 History模式
- `routes`: 路由配置
- `beforeEach()`: 路由守卫（检查认证）

### 步骤6: 创建API客户端

```javascript
import axios from 'axios'
import { ElMessage } from 'element-plus'

const api = axios.create({
  baseURL: '/api/v1',
  timeout: 10000
})

api.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
    ElMessage.error(error.response?.data?.detail || '请求失败')
    return Promise.reject(error)
  }
)

export default api
```

**说明**:
- `axios.create()`: 创建axios实例
- `baseURL`: API基础URL
- `interceptors.request.use()`: 请求拦截器（添加token）
- `interceptors.response.use()`: 响应拦截器（处理错误）

### 步骤7: 创建状态管理

```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import api from '../api'

export const useUserStore = defineStore('user', () => {
  const user = ref(null)
  const token = ref(localStorage.getItem('token'))

  async function login(credentials) {
    const response = await api.post('/users/login/', credentials)
    token.value = response.data.access
    user.value = response.data.user
    localStorage.setItem('token', token.value)
    localStorage.setItem('refresh', response.data.refresh)
    return response.data
  }

  async function register(data) {
    const response = await api.post('/users/register/', data)
    return response.data
  }

  async function logout() {
    await api.post('/users/logout/')
    token.value = null
    user.value = null
    localStorage.removeItem('token')
    localStorage.removeItem('refresh')
  }

  async function fetchUser() {
    const response = await api.get('/users/profile/')
    user.value = response.data
    return response.data
  }

  return { user, token, login, register, logout, fetchUser }
})
```

**说明**:
- `defineStore()`: 定义Pinia store
- `ref()`: 响应式状态
- `login()`: 登录方法
- `register()`: 注册方法
- `logout()`: 登出方法
- `fetchUser()`: 获取用户信息

### 步骤8: 创建组件

```vue
<template>
  <div class="login-page">
    <div class="login-container">
      <h1>八股炉</h1>
      <el-form :model="form" @submit.prevent="handleLogin">
        <el-form-item>
          <el-input v-model="form.username" placeholder="用户名" />
        </el-form-item>
        <el-form-item>
          <el-input v-model="form.password" type="password" placeholder="密码" />
        </el-form-item>
        <el-form-item>
          <el-button type="primary" @click="handleLogin" :loading="loading">登录</el-button>
        </el-form-item>
      </el-form>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '@/stores/user'
import { ElMessage } from 'element-plus'

const router = useRouter()
const userStore = useUserStore()

const form = ref({
  username: '',
  password: ''
})
const loading = ref(false)

async function handleLogin() {
  loading.value = true
  try {
    await userStore.login(form.value)
    ElMessage.success('登录成功')
    router.push('/dashboard')
  } catch (error) {
    ElMessage.error('登录失败')
  } finally {
    loading.value = false
  }
}
</script>

<style scoped>
.login-page {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background: #f5f5f5;
}

.login-container {
  width: 400px;
  padding: 40px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
}
</style>
```

**说明**:
- `<template>`: 组件模板
- `<script setup>`: 组件逻辑（组合式API）
- `<style scoped>`: 组件样式（作用域样式）
- `ref()`: 响应式数据
- `useRouter()`: 路由实例
- `useUserStore()`: 用户状态管理

### 步骤9: 运行开发服务器

```bash
npm run dev
```

**说明**:
- 启动Vite开发服务器
- 默认地址: http://localhost:5173

---

## 数据库设计

### 用户表 (User)

```python
class User(AbstractUser):
    email = models.EmailField(unique=True, verbose_name='邮箱')
    bio = models.TextField(blank=True, verbose_name='个人简介')
    avatar = models.ImageField(upload_to='avatars/', null=True, blank=True, verbose_name='头像')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
```

**说明**:
- 继承Django的`AbstractUser`（包含用户名、密码等基础字段）
- `email`: 邮箱（唯一）
- `bio`: 个人简介
- `avatar`: 头像（图片文件）
- `created_at`: 创建时间（自动）
- `updated_at`: 更新时间（自动）

### 题目表 (Question)

```python
class Question(SoftDeleteModel):
    title = models.CharField(max_length=200, verbose_name='标题')
    content = models.TextField(verbose_name='内容')
    answer = models.TextField(verbose_name='答案')
    explanation = models.TextField(blank=True, verbose_name='解析')
    difficulty = models.IntegerField(verbose_name='难度')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, verbose_name='分类')
    tags = models.JSONField(default=list, blank=True, verbose_name='标签')
    creator = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, verbose_name='创建者')
    is_public = models.BooleanField(default=True, verbose_name='是否公开')
    is_approved = models.BooleanField(default=False, verbose_name='是否审核通过')
    view_count = models.IntegerField(default=0, verbose_name='浏览次数')
    avg_score = models.FloatField(default=0, verbose_name='平均分')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
```

**说明**:
- 继承`SoftDeleteModel`（支持软删除）
- `title`: 题目标题
- `content`: 题目内容
- `answer`: 答案
- `explanation`: 解析
- `difficulty`: 难度（1-4）
- `category`: 分类（外键）
- `tags`: 标签（JSON数组）
- `creator`: 创建者（外键）
- `is_public`: 是否公开
- `is_approved`: 是否审核通过
- `view_count`: 浏览次数
- `avg_score`: 平均分

### 答题记录表 (Interaction)

```python
class Interaction(SoftDeleteModel):
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='用户')
    question = models.ForeignKey(Question, on_delete=models.CASCADE, verbose_name='题目')
    answer = models.TextField(verbose_name='答案')
    score = models.FloatField(null=True, blank=True, verbose_name='得分')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending', verbose_name='状态')
    is_submitted = models.BooleanField(default=False, verbose_name='是否提交')
    is_favorite = models.BooleanField(default=False, verbose_name='是否收藏')
    time_spent = models.IntegerField(default=0, verbose_name='用时（秒）')
    attempts = models.IntegerField(default=1, verbose_name='尝试次数')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')
```

**说明**:
- `user`: 用户（外键）
- `question`: 题目（外键）
- `answer`: 用户答案
- `score`: 得分
- `status`: 状态（pending/completed）
- `is_submitted`: 是否提交
- `is_favorite`: 是否收藏
- `time_spent`: 用时（秒）
- `attempts`: 尝试次数

### 推荐表 (Recommendation)

```python
class Recommendation(SoftDeleteModel):
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='用户')
    question = models.ForeignKey(Question, on_delete=models.CASCADE, verbose_name='题目')
    score = models.FloatField(verbose_name='推荐分数')
    reason = models.TextField(verbose_name='推荐理由')
    algorithm = models.CharField(max_length=50, verbose_name='算法')
    is_viewed = models.BooleanField(default=False, verbose_name='是否已查看')
    is_answered = models.BooleanField(default=False, verbose_name='是否已答题')
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
```

**说明**:
- `user`: 用户（外键）
- `question`: 题目（外键）
- `score`: 推荐分数
- `reason`: 推荐理由
- `algorithm`: 算法类型
- `is_viewed`: 是否已查看
- `is_answered`: 是否已答题

### 用户相似度表 (UserSimilarity)

```python
class UserSimilarity(models.Model):
    user_a = models.ForeignKey(User, on_delete=models.CASCADE, related_name='similarities_a', verbose_name='用户A')
    user_b = models.ForeignKey(User, on_delete=models.CASCADE, related_name='similarities_b', verbose_name='用户B')
    similarity_score = models.FloatField(verbose_name='相似度分数')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='更新时间')

    class Meta:
        unique_together = ('user_a', 'user_b')
```

**说明**:
- `user_a`: 用户A（外键）
- `user_b`: 用户B（外键）
- `similarity_score`: 相似度分数（0-1）
- `unique_together`: 用户对唯一

---

## 核心功能实现

### 1. 用户认证

#### 后端实现

```python
class LoginView(generics.CreateAPIView):
    permission_classes = [AllowAny]
    serializer_class = LoginSerializer

    def post(self, request):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data['user']
        refresh = RefreshToken.for_user(user)
        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': UserSerializer(user).data
        })
```

**说明**:
- `LoginView`: 登录视图
- `AllowAny`: 允许匿名访问
- `LoginSerializer`: 登录序列化器
- `RefreshToken.for_user()`: 生成JWT令牌

#### 前端实现

```javascript
async function login(credentials) {
  const response = await api.post('/users/login/', credentials)
  token.value = response.data.access
  user.value = response.data.user
  localStorage.setItem('token', token.value)
  localStorage.setItem('refresh', response.data.refresh)
  return response.data
}
```

**说明**:
- 发送登录请求
- 保存token到localStorage
- 保存用户信息到store

### 2. 题目推荐

#### 后端实现

```python
class CollaborativeFiltering:
    @staticmethod
    def user_based_recommend(user, n=10, min_similarity=0.1):
        answered_questions = set(
            Interaction.objects.filter(
                user=user,
                is_submitted=True
            ).values_list('question_id', flat=True)
        )

        if len(answered_questions) < 3:
            return CollaborativeFiltering._popular_questions_recommend(user, n, answered_questions)

        similar_users = UserSimilarity.objects.filter(
            Q(user_a=user) | Q(user_b=user),
            similarity_score__gte=min_similarity
        ).order_by('-similarity_score')

        recommendations = defaultdict(float)
        reasons = defaultdict(list)

        for sim in similar_users:
            similar_user = sim.user_b if sim.user_a == user else sim.user_a
            similar_user_interactions = Interaction.objects.filter(
                user=similar_user,
                score__isnull=False,
                is_submitted=True,
                score__gte=60
            ).exclude(question_id__in=answered_questions)

            for interaction in similar_user_interactions:
                question_id = interaction.question_id
                score = interaction.score
                rec_score = sim.similarity_score * (score / 100)
                recommendations[question_id] += rec_score
                reasons[question_id].append(
                    f"相似用户 {similar_user.username} 得分 {score}"
                )

        sorted_recommendations = sorted(
            recommendations.items(),
            key=lambda x: x[1],
            reverse=True
        )[:n]

        result = []
        for question_id, score in sorted_recommendations:
            question = Question.objects.get(id=question_id)
            reason = "、".join(reasons[question_id])
            result.append((question, score, reason))

        return result
```

**说明**:
- 获取用户已答题目
- 冷启动处理（答题数<3使用热门题目）
- 获取相似用户
- 计算推荐分数（相似度 × 用户评分）
- 返回推荐结果

#### 前端实现

```javascript
async function fetchRecommendations() {
  loading.value = true
  try {
    const response = await api.get('/recommender/recommendations/generate_recommendations/', {
      params: {
        type: recommendationType.value,
        n: 10,
        min_similarity: 0.1
      }
    })
    recommendations.value = response.data.recommendations
    return response.data
  } catch (err) {
    error.value = err.message
    throw err
  } finally {
    loading.value = false
  }
}
```

**说明**:
- 发送推荐请求
- 保存推荐结果到store
- 处理加载状态和错误

### 3. 答题评分

#### 后端实现

```python
class ScoringStrategy(ABC):
    @abstractmethod
    def score(self, user_answer: str, correct_answer: str, question: Question) -> float:
        pass

class KeywordMatchingStrategy(ScoringStrategy):
    def score(self, user_answer: str, correct_answer: str, question: Question) -> float:
        keywords = self._extract_keywords(correct_answer)
        matched = sum(1 for kw in keywords if kw in user_answer)
        return (matched / len(keywords)) * 100 if keywords else 0

    def _extract_keywords(self, text: str) -> List[str]:
        return re.findall(r'\b\w+\b', text.lower())

class SemanticMatchingStrategy(ScoringStrategy):
    def __init__(self):
        self.model = SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')

    def score(self, user_answer: str, correct_answer: str, question: Question) -> float:
        embeddings = self.model.encode([user_answer, correct_answer])
        similarity = util.cos_sim(embeddings[0], embeddings[1]).item()
        return similarity * 100
```

**说明**:
- `ScoringStrategy`: 评分策略抽象基类
- `KeywordMatchingStrategy`: 关键词匹配策略
- `SemanticMatchingStrategy`: 语义匹配策略（使用sentence-transformers）

#### 前端实现

```vue
<template>
  <div class="answer-input">
    <el-input
      v-model="answer"
      type="textarea"
      :rows="6"
      placeholder="请输入你的答案..."
      @input="handleInput"
    />
    <el-button type="primary" @click="handleSubmit" :loading="loading">
      提交答案
    </el-button>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { usePracticeStore } from '@/stores/practice'

const practiceStore = usePracticeStore()

const answer = ref('')
const loading = ref(false)

async function handleSubmit() {
  loading.value = true
  try {
    await practiceStore.submitAnswer({
      question_id: props.questionId,
      answer: answer.value
    })
    ElMessage.success('提交成功')
  } catch (error) {
    ElMessage.error('提交失败')
  } finally {
    loading.value = false
  }
}
</script>
```

**说明**:
- 答案输入组件
- 提交答案到后端
- 显示加载状态

### 4. 数据分析

#### 后端实现

```python
class UserAnalyticsView(generics.RetrieveAPIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        interactions = Interaction.objects.filter(user=user, is_submitted=True)

        total_questions = interactions.count()
        correct_questions = interactions.filter(score__gte=60).count()
        accuracy = (correct_questions / total_questions * 100) if total_questions > 0 else 0
        avg_score = interactions.aggregate(avg=Avg('score'))['avg'] or 0

        category_stats = interactions.values('question__category__name').annotate(
            count=Count('id'),
            avg_score=Avg('score')
        )

        return Response({
            'total_questions': total_questions,
            'correct_questions': correct_questions,
            'accuracy': accuracy,
            'avg_score': avg_score,
            'category_stats': list(category_stats)
        })
```

**说明**:
- 获取用户答题数据
- 计算总题数、正确数、准确率、平均分
- 按分类统计

#### 前端实现

```vue
<template>
  <div class="analytics">
    <el-row :gutter="20">
      <el-col :span="6">
        <stat-card :value="stats.total_questions" label="总题数" type="primary" />
      </el-col>
      <el-col :span="6">
        <stat-card :value="stats.correct_questions" label="正确数" type="success" />
      </el-col>
      <el-col :span="6">
        <stat-card :value="stats.accuracy.toFixed(2) + '%'" label="准确率" type="warning" />
      </el-col>
      <el-col :span="6">
        <stat-card :value="stats.avg_score.toFixed(2)" label="平均分" type="danger" />
      </el-col>
    </el-row>

    <el-card class="chart-card">
      <div ref="chartRef" style="width: 100%; height: 400px;"></div>
    </el-card>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import * as echarts from 'echarts'
import StatCard from '@/components/common/StatCard.vue'

const chartRef = ref(null)
const stats = ref({
  total_questions: 0,
  correct_questions: 0,
  accuracy: 0,
  avg_score: 0
})

onMounted(async () => {
  const response = await api.get('/analytics/user-analytics/')
  stats.value = response.data

  const chart = echarts.init(chartRef.value)
  chart.setOption({
    title: { text: '分类统计' },
    xAxis: { data: response.data.category_stats.map(s => s.category) },
    yAxis: {},
    series: [{
      type: 'bar',
      data: response.data.category_stats.map(s => s.count)
    }]
  })
})
</script>
```

**说明**:
- 显示统计卡片
- 使用ECharts绘制图表
- 响应式数据绑定

---

## 部署指南

### 1. 环境变量配置

创建 `.env` 文件：

```env
SECRET_KEY=your-secret-key-here
DEBUG=False
ALLOWED_HOSTS=yourdomain.com,www.yourdomain.com
DATABASE_URL=postgresql://user:password@localhost:5432/interview_system
REDIS_URL=redis://localhost:6379/0
USE_REDIS=True
```

**说明**:
- `SECRET_KEY`: Django加密密钥
- `DEBUG`: 调试模式（生产环境设为False）
- `ALLOWED_HOSTS`: 允许访问的主机
- `DATABASE_URL`: 数据库连接URL
- `REDIS_URL`: Redis连接URL

### 2. 生产环境配置

```python
if not DEBUG:
    SECURE_SSL_REDIRECT = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    SECURE_BROWSER_XSS_FILTER = True
    X_FRAME_OPTIONS = 'DENY'
```

**说明**:
- `SECURE_SSL_REDIRECT`: 强制HTTPS
- `SECURE_HSTS_*`: HSTS安全头
- `SESSION_COOKIE_SECURE`: 安全Cookie
- `CSRF_COOKIE_SECURE`: CSRF保护
- `X_FRAME_OPTIONS`: 点击劫持防护

### 3. Docker部署

#### Dockerfile（后端）

```dockerfile
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN python manage.py collectstatic --noinput
RUN python manage.py migrate

EXPOSE 8000

CMD ["gunicorn", "core.wsgi:application", "--bind", "0.0.0.0:8000"]
```

**说明**:
- 使用Python 3.10镜像
- 安装依赖
- 收集静态文件
- 运行数据库迁移
- 使用Gunicorn运行应用

#### Dockerfile（前端）

```dockerfile
FROM node:20-alpine as builder

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**说明**:
- 多阶段构建
- 构建前端应用
- 使用Nginx提供静态文件

#### docker-compose.yml

```yaml
version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: interview_system
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    volumes:
      - redis_data:/data

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/interview_system
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
```

**说明**:
- `db`: PostgreSQL数据库
- `redis`: Redis缓存
- `backend`: 后端服务
- `frontend`: 前端服务
- `volumes`: 数据持久化

### 4. 启动服务

```bash
docker-compose up -d
```

**说明**:
- `-d`: 后台运行
- 启动所有服务

### 5. 常用命令

```bash
# 查看日志
docker-compose logs -f backend

# 重启服务
docker-compose restart backend

# 停止服务
docker-compose down

# 进入容器
docker-compose exec backend bash

# 运行Django命令
docker-compose exec backend python manage.py createsuperuser
```

**说明**:
- `logs`: 查看日志
- `restart`: 重启服务
- `down`: 停止服务
- `exec`: 执行命令

---

## 总结

本指南详细介绍了程序员八股文题目训练系统的完整搭建流程，包括：

1. **项目概述**: 介绍项目功能和核心特性
2. **技术栈**: 列出使用的技术和框架
3. **环境准备**: 搭建开发环境
4. **后端搭建**: Django项目配置和应用创建
5. **前端搭建**: Vue项目配置和组件开发
6. **数据库设计**: 核心数据模型设计
7. **核心功能**: 用户认证、题目推荐、答题评分、数据分析
8. **部署指南**: 生产环境配置和Docker部署

通过本指南，你可以从零开始复刻整个项目，理解每个部分的作用和实现原理。祝你学习愉快！
